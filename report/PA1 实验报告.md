# PA2 报告

佘帅杰 181860077

### 实验问题解答

#### PA2-1

##### 1. 使用 hexdump 命令查看测试用例的.img 文件，所显示的.img 文件的内容对应模拟内存的哪一个部分？指令在机器中表示的形式是什么？

根据前文实验手册里所说，NEMU约定第一条置零存储在内存0x30000初，在NEMU初始化的时候会做的两件事情1. 把测试用例镜像文件的内容拷贝到0x30000开始的连续区域，然后初始化eip为0x30000。img文件就是这个镜像文件，被拷贝到模拟内存0x30000的位置，在这一部分的内存里，指令在机器里是以二进制位串机器数的形式表示并以小端方式存储的，hexdump可以看作是对这一组二进制文件使用16进制进行解析打开。对应的内容应该是模拟内存的代码节，数据节，还有eh_frame节。

##### 2. 如果去掉 instr_execute_2op()函数前面的 static 关键字会发生什么情况？为什么？

加了static后表示该函数失去了全局可见性，只在该函数所在的文件作用域内可见。当函数声明为static以后,编译器在该目标编译单元内只含有该函数的入口地址,没有函数名,其它编译单元便不能通过该函数名来调用该函数。去掉stastic之后，比如在mov里写了一个op函数实现mov指令共有的移动功能，然后在写jmp的时候由于框架代码里写好的是调用这么一个名字是instr_execute_2op()的函数，那么又写了这么一同名的功能函数来实现jmp指令共有的跳转功能。那么这两个函数就重名了，在编译的时候编译器不知道这两个函数的区别。在调用的时候也会有问题。

##### 3. test_float为什么会fail?

因为这段代码本来就有问题，下面贴出了代码，可以清楚的看到，这里是两个float型的数进行操作，如果结果和常理完全相等才能hit_good_trap，但是问题就在于这里是浮点数操作，首先不是所有的数都可以被二进制小数精确的表示的（比如0.1），所以这里强行把1.2赋值给float的时候就有了一点问题，float大概只支持7位左右的数值，1.2在赋值的时候值就有点不对了。第二，浮点数的运算的一大特点就是对阶，对阶就会发生移位，移位就容易丢失或者多出来数据，虽然在实现fpu的时候我们采取了手段让他尽可能的精确，但是误差是可能发生的，这里对两个float进行各种的操作，结果再赋给一个float类型，在这个过程中发生了数据的改变，使得等式不成立进而hit_bad_trap。

书写有关于float类型的代码的时候就有一些需要注意的了

1. 改进算法使用Kahan summation算法
2. 在判断的时候不要用==，可以尝试的使用二者相减小于一个很小数作为条件如：c-1.2<0.000001
3. 可以尝试double类型，更大的数据更多的位数，能够进一步减小误差

```c
#include "trap.h"

int main()
{

	float a = 1.2, b = 1;
	float c = a + b;
	if (c == 2.2)
		;
	else
		HIT_BAD_TRAP;
	c = a * b;
	if (c == 1.2)
		;
	else
		HIT_BAD_TRAP;

	c = a / b;
	if (c == 1.2)
		;
	else
		HIT_BAD_TRAP;

	c = a - b;
	if (c == 0.2) // this will fail, and also fails for native program, interesting, can be used as a quiz
		;
	else
		HIT_BAD_TRAP;

	HIT_GOOD_TRAP;
	return 0;
}
```

#### PA2-2

##### 1.为什么 在装载时要把内存中剩余的 p_memsz - p_filesz 字节的内容清零 ?

基于对这个模块代码功能的判断，我认为后面的内存空间是没有用到的，直接清零做初始化的操作很正常。。。。里面万一又上次遗留的或者是什么奇怪的数据，没有清零可能会引发一些不良的影响。

#### PA2-3

##### 1.我们在 add.c 中定义了宏 NR_DATA , 同时也在 add() 函数中定义了局部变量 函数中定义了局部变量 c 和形参 a , b , 但你会发 现在符号表中找不到和它们对应的项 , 为什么会这样 ? 思考一下 , 什么才算是一个符号 (symbol)?

宏在编译的时候就会被直接展开替换为代码文本。而局部变量只有在运行到规定的位置的时候才会分配内存空间，确定下来，至于形式参数并不是直接存在的，只是为了接受参数用的。同时局部变量和宏的作用域有限，也不会被其他模块的函数进行调用，所以也没有必要把他们写在符号表里，况且一个是一开始就没了，另一个是运行到了才确定。再从二者的存储空间的分配上来看，宏定义不分配空间，局部变量也只是分配在栈里

从另一个方面来看。

1. 什么是符号表？目标文件中的"符号表"(symbol table)中所包含的信息用于定位和重定位程序中的符号定义和符号引用。符号表保存了查找程序符号、为符号赋值、重定位符号所需的全部信息。
2. 符号是表示每个ELF文件的一个重要部分，因为它保存了程序实现或使用的所有（全局）变量和函数。如果程序引用了一个自身代码未定义的符号，则称之为未定义的符号（例如一般程序中printf函数，就定义在c标准函数中）。此类引用必须在静态链接期间用其他目标模块或者库解决，或在加载期间通过动态链接（使用ld-linux.so）解决。nm工具可以生成程序定义和使用的所有符合列表。
3. 符号的主要任务是讲一个字符串和一个值关联起来。例如，printf符号表示printf函数在虚拟地址空间中的地址，该函数的机器代码就存在于该地址。符号也可能有绝对值，由程序解释，例如数值常数。

对照这来看，局部变量和宏还有形式参数显然是不够资格被称为符号的，符号应该是那些全局变量以及函数的名称，他们有可能会被调用，又会在编译的时候被很好的确定下来，所以有必要像登记花名册一样被记录，方便于使用



